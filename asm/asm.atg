COMPILER Asm

   funcs = {}
   variables  = {}
   labels = {}
   ip = 0
   #cmd = 0
   curfunc = None
   
   code = []
   #code_ip = 0
   
   
   
   def isNext(self, ch):
      self.scanner.ResetPeek()
      s = self.scanner.Peek().val
      return s == ch
   
   def compoundCode(self, entry):
      sz = 0
      self.ip = 0
      if entry in self.funcs :
         foo = self.funcs[entry]
         self.code.append(0)
         self.code.append(0)
         sz_ip = self.ip
         self.ip += 2
         #self.ip += 1
         sz = self.addFooToCode(foo)
         self.code[sz_ip] = sz
      return sz
										   
   
   def addFooToCode(self, foo):
      b_ip = self.ip
      iip = 0
      sz = foo['ip']
      for i in xrange(0, foo['ip']) :
         self.code.append(foo['code'][i])
         iip += 1
         self.ip += 1
      for nm in foo['names'] :
         print nm
         o = foo['names'][nm]
         if o['type'] == 'foo' :
	    if nm in foo['xref'] :
               self.code.append(0)
               self.code.append(0)
               isz_ip = self.ip
               self.ip += 2
               #self.ip += 1
	       ptlst = foo['xref'][nm]
	       for pt in ptlst :
                  print "b_ip=%d, pt=%d, isz_ip=%d, old_code=%d" % (b_ip, pt, isz_ip, self.code[b_ip + pt], )
	          self.code[b_ip + pt] += iip
               isz = self.addFooToCode(o['foo'])
               print "isz=", isz, ", isz_ip=", isz_ip
	       iip += isz
               self.code[isz_ip] = isz
               sz += isz
      print "sz=", sz
      return sz


   def getCode(self):
      return self.code
      
      
      

CHARACTERS
  letter   = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .
  digit    = "0123456789" .
  hexdigit = digit + "ABCDEFabcdef" .
  bindigit = "01" .
  tab      = CHR(9) .
  eol      = CHR(10) .
  files    = letter + digit + ":\\." .
  chars    = CHR(32) .. CHR(255) - "'" .
  strings  = CHR(32) .. CHR(255) - '"'.
  macros   = ANY - eol .

TOKENS
  identifier = ( "_" | letter) { "_" | letter | digit } .
  number     = digit { digit } [ "." { digit }] [ "U" | "u" | "L" | "l" ] .
/*
  hexnumber  = "0" ( "x" | "X" ) hexdigit { hexdigit } [ "U" | "u" | "L" | "l" ] .
*/
  hexnumber  = "h'" hexdigit { hexdigit } [ "U" | "u" | "L" | "l" ] .
  binnumber  = "b'" bindigit { bindigit } [ "U" | "u" | "L" | "l" ] .
  string     = '"' { strings } '"' .
  char       = "'" [ "\\" ] chars "'" .
  library    = "<" files { files } ">" .

PRAGMAS
  PreProcessor = "#" {macros} .

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO eol

IGNORE tab + eol + CHR(13)

PRODUCTIONS

  Asm				= 						(. entry = None .)
				{ 
				  Definition<None, None> 
				} 
				[
				  "entry" ":" identifier 			(. entry = self.token.val .)
				  "."
				]
				EOF 
										(.
										   self.compoundCode(entry)
										   
										   #for i in xrange(0, self.ip):
										   #   cmd = self.code[i]
										   #   print "%08x : 0x%X" % (cmd, i)
										.)
				.

/* Variable and Type Definitions */

  Definition<upperfname, upperfoo> 
				= 
				(
				    "def" identifier				(. 
										   name = self.token.val
										   #if upperfname != None :
										      #name = upperfname + '.' + name
										      #name = name
										   idip = self.ip 
										.)
				   FunctionDefinition<name, idip, upperfoo>
//				";" 
				) 
				.


  VarList<foo>			= identifier 					(. name = self.token.val .)
				    ArraySize<out dims>				(. 
										   #print name
										   #print dims
										   if dims['cnt'] == 0 :
										      dims['size'] = 1
										   size = dims['size']
										   foo['vars'][name] = {'name': name, 'size': size, 'ip': None, 'dims': dims, }
										   foo['names'][name] = {'type': 'var', 'name': name, 'size': size, 'ip': None, 'dims': dims, }
										.)
				.

  ArraySize<out dims>		= 						(. dims = {'size': 1, 'dim': [], 'cnt': 0, } .)
				{ "[" (
				     number 					(. i = int( self.token.val ) .)
				   | hexnumber
				  ) "]"						(.
										   dims['size'] *= i
										   dims['cnt']  += 1
										   dims['dim'].append(i)
										.)
				} 
				.

/* Function Definitions */

  FunctionDefinition<fname, idip, upperfoo>
				= FunctionHeader<out foo, fname> 
				( 
				  ";" 
				| FunctionBody<fname, idip, foo> 		(.
										   if upperfoo != None :
										      upperfoo['foos'].append(foo)
										      upperfoo['names'][fname] = {'type': 'foo', 'ip': 0, 'foo': foo, }
										      #print upperfoo['names'][fname]
										      #print fname
										.)
				) 
				.

  FunctionHeader<out foo, fname>
				= "(" [ FormalParamList ] ")"			(.
										   if (fname in self.funcs) and self.funcs[fname]['f_ip'] != None:
										      self.SemErr( "Error: dublicated function name '%s'" % (fname,) )
										   else:
										      regs = []
										      for i in xrange(0,15) :
										         regs.append(0)
										      regs.append(16)
										      foo = {'fname': fname, 'f_ip': None, 'vars': {}, 'lbls': {}, 'regs': regs, 'code': [], 'xref': {}, 'ip': 0, 'names': {}, 'foos': [], }
										      self.funcs[fname] = foo
										      self.curfunc = fname
										.)
				.

  FunctionBody<fname, idip, foo> 
				= CompoundStatement<fname, foo>			(. 
										   #if (fname in self.funcs) and self.funcs[fname]['ip'] != None:
										   #   print "// error dublicated function name"
										   #else:
										   self.funcs[fname]['f_ip'] = 0 #idip
										   #print "// '%s' -> 0x%X\n%s" % (fname, idip, self.funcs[fname])
										   
										   for lbl in foo['xref'] :
										      #print lbl
										      nmip = 0
										      if lbl not in foo['names'] :
										         self.SemErr( "Error: use of not defined label '%s'" % (lbl,) )
										      ptlst = foo['xref'][lbl]
										      nmo = foo['names'][lbl]
										      if nmo['type'] == 'var' :
										         nmip = foo['ip']
										         nmo['ip'] = nmip
										         for i in xrange(0, nmo['size']) :
										            foo['code'].append(0)
										         foo['ip'] += nmo['size']
										      elif nmo['type'] == 'label' :
										         nmip = nmo['ip']
										      for n in ptlst :
										         #print "nmip = , n = " 
										         #print nmip
										         #print n
										         foo['code'][n] += nmip
										.)
				.

  FormalParamList      = FormalParameter { "," FormalParameter } .

  FormalParameter      = identifier 
//				ArraySize 
				.

/* Statements */

  Statement<foo>		= 
				(
				    IF(self.isNext(':')) Label<foo> 
				  | AssignmentExpression<foo> 
//				| BreakStatement
//                           | CompoundStatement | ContinueStatement
//                           | DoStatement | ForStatement
//                           | IfStatement 
				  | NullStatement
//                           | ReturnStatement | SwitchStatement
//                           | WhileStatement 
				) 
				.

  Label<foo>			= 
				identifier					(. 
										   lbl = self.token.val
										.)
				":"						(.
										   if not (lbl in self.funcs[self.curfunc]['lbls']) :
										      foo['lbls'][lbl] = foo['ip']
										      foo['names'][lbl] = {'type': 'label', 'ip': foo['ip']}
										   else:
										      self.SemErr( "Error: dublicated label '%s'" % (lbl,) )
										.)
			.
//			"case" ConstExpression ":"  |  "default" ":" .

/* There is no requirement that a switch statement be followed by a compound
   statement.  Actually labels may be even more general */

  AssignmentExpression<foo>	= 
				Expression<out cmd, foo> ";" 			(.
										   foo['code'].append(cmd)
										   foo['ip'] += 1
										.)
				.

//  BreakStatement       = "break" ";" .

  CompoundStatement<fname, foo>	= 
				"{" 
				 ["init" "{" { 
				   RegName< out r > "=" Const<out num, foo> 
				   ";"						(. foo['regs'][r['r']] = num .)
				 } "}" ] 					(.
										   for i in xrange(0, 16) :
										      foo['code'].append(foo['regs'][i])
										      foo['ip'] += 1
										.)
				 [ "var" "{" { LocalDeclaration<foo> } "}" ]
				 { 
				    Statement<foo> 
				  | Definition<fname, foo>
				 } 
				 "}" 
				.

//  ContinueStatement    = "continue" ";" .

//  DoStatement          = "do" Statement "while" "(" Expression ")" ";" .

//  ForStatement         = "for"  "(" [ Expression ] ";" [ Expression ] ";" [ Expression ] ")" Statement .

//  IfStatement          = "if" "(" Expression ")" Statement [ "else" Statement ] .

  NullStatement 		= 
				";" 
				.

//  ReturnStatement      = "return" [ Expression ] ";" .
                         /* Expression usually in parentheses */

//  SwitchStatement      = "switch" "(" Expression ")" Statement .

//  WhileStatement       = "while" "(" Expression ")" Statement .

/* LocalDeclarations */

  LocalDeclaration<foo>
				= 
//				identifier					(. 
//										   name = self.token.val
//										   idip = self.ip 
//										.)
//                          ( /*FunctionHeader<name> |*/ 
				VarList<foo> 
//						  ) 
				";"  
				.

/* Expressions, based on Kernighan and Ritchie: "The C Programming Language".
   There does not seem to be a way to make this work in an LL(1) fashion,
   but this generates a "working" parser */

//  ConstExpression      = Expression<out cmd> .

  Expression<out cmd, foo>	= 						(. 
										   cmd = 0 
										   cond = {'r': 0, 'rop': 3, 'isptr': 0}
										.)
				(
				   Dst<out dst> ("=" | "<-") 
						(
						    Src<out src0> 
						    Operation<out op> 
						    Src<out src1>
						  | "fork" 			(. op = 14 .)
						    Src<out src0> 
						    "(" Src<out src1> ")"
						  | "stop" 			(. op = 15 .)
						    Src<out src0> 
						    "(" Src<out src1> ")"
						)
				   [ "?" Cond<out cond>  
				   ] 
										(.
										   cmd |= (cond['r'] << 12) | (cond['rop'] << 26) | (cond['isptr'] << 19)
										   cmd |= (dst['r'] << 8) | (dst['rop'] << 24) | (dst['isptr'] << 18)
										   cmd |= (src1['r'] << 0) | (src1['rop'] << 20) | (src1['isptr'] << 16)
										   cmd |= (src0['r'] << 4) | (src0['rop'] << 22) | (src0['isptr'] << 17)
										   cmd |= (op << 28)
										.)
				 | Const<out num, foo>				(. cmd = num .)
				)						(.
										   #self.code.append(cmd)
										   #self.ip += 1
										   #print "%08x\t// 0x%X" % (cmd, self.ip)
										   #self.ip += 1
										.)
				.
				
//Conditional { AssignmentOperator Expression }.

  Operation<out op>		= 						(. op = 0 .)
				(
				    "|"						(. op = 9 .)
				  | "^"						(. op = 7 .)
				  | "&"						(. op = 8 .)
				  | "<<"					(. op = 6 .)
				  | ">>"					(. op = 5 .)
				  | "+"						(. op = 1 .)
				  | "-"						(. op = 2 .)
				  | "*"						(. op = 3 .)
				  | "/"						(. op = 4 .)
				  | "<-"					(. op = 0 .)
//				  | 
//				  | 
//				  | 
//				  |
				)
				.

  Const<out num, foo> 	= Conditional<out num, foo>.

  Conditional<out num, foo>	= LogORExp<out num, foo> .

  LogORExp<out num, foo>	= LogANDExp<out num, foo>   { "||" LogANDExp<out num, foo> } .

  LogANDExp<out num, foo>	= InclORExp<out num, foo>   { "&&" InclORExp<out num, foo> }.

  InclORExp<out num, foo>	= ExclORExp<out num, foo>   { "|" ExclORExp<out num, foo> } .

  ExclORExp<out num, foo>	= ANDExp<out num, foo>      { "^" ANDExp<out num, foo> } .

  ANDExp<out num, foo>	= EqualExp<out num, foo>    { "&" EqualExp<out num, foo> } .

  EqualExp<out num, foo>	= RelationExp<out num, foo> { ( "==" | "!=" ) RelationExp<out num, foo> } .

  RelationExp<out num, foo>	= ShiftExp<out num, foo>    { ( "<" | ">" | "<=" | ">=" ) ShiftExp<out num, foo> }.

  ShiftExp<out num, foo>	= AddExp<out num, foo>      { ( "<<" | ">>" ) AddExp<out num, foo> } .

  AddExp<out num, foo>	= MultExp<out num, foo>     { ( "+" | "-" ) MultExp<out num, foo> } .

  MultExp<out num, foo>	= CastExp<out num, foo>     { ( "*" | "/" | "%" ) CastExp<out num, foo> } .

  CastExp<out num, foo>	= UnaryExp<out num, foo> .

/* we should really add
                         | "(" identifier ")" CastExp .
   but this breaks it badly */

  UnaryExp<out num, foo>	=  PostFixExp<out num, foo>
//                         | ( "++" | "--" ) UnaryExp
                         | UnaryOperator CastExp<out num, foo> .

/* we should really add
                         | "sizeof" ( UnaryExp | "(" Type ")" ) .
   but this breaks it badly */

  PostFixExp<out num, foo>	= 
				Primary<out num, foo>
				{ 
//				    "[" Expression "]"
//				  | FunctionCall
				    "." identifier
//				  | "->" identifier
//				  | "++"
//				  | "--"
				} 
				.

  Primary<out num, foo>		= 						(. num = 0 .)
				(
				    identifier 					(. 
										   lbl = self.token.val
										   num = 0
										   #if lbl in foo['lbls'] :
										   #   num = foo['lbls'][lbl]
										   #else:
										   #   self.SemErr( "Error: use of not defined label '%s'" % (lbl,) )
										   if lbl not in foo['xref'] :
										      foo['xref'][lbl] = []
										   xref = foo['ip']
										   #
										   dim_cnt = 0
										   o_desc = None
										   o_dims = None
										   if lbl in foo['names'] :
										      o_desc = foo['names'][lbl]
										   #
										   if o_desc != None and o_desc['type'] == 'var' :
										      o_dims = o_desc['dims']
										.)
				     { "["					(.
										   if o_desc == None :
										      self.SemErr( "Error: variable '%s' is not defined" % (lbl,) )
										   #
										   if o_desc['type'] != 'var' :
										      self.SemErr( "Error: %s '%s' used as varible" % (o_desc['type'], lbl,) )
										   #
										   if o_dims['cnt'] <= dim_cnt :
										      self.SemErr( "Error: variable '%s' has only %d dimensions" % (lbl, o_dims['cnt'], ) )
										.)
				          Const<out i, foo> 
				        "]"					(.
										   if o_dims['cnt'] > dim_cnt :
										      if o_dims['dim'][dim_cnt] <= i :
										         self.SemErr( "Error: variable '%s' has dimension %d  [0 .. %d], but [%d]" % (lbl, dim_cnt, o_dims['dim'][dim_cnt] - 1, i, ) )
										      num *= o_dims['dim'][dim_cnt]
										      num += i
										   dim_cnt += 1
										.)
				     }						(. foo['xref'][lbl].append(xref) .)
				  | string					(.
										   #print self.token.val
										   num = 0
										.)
				  | char 
				  | hexnumber 				(. num = int( self.token.val[2:], 16 ) .)
				  | binnumber 				(. num = int( self.token.val[2:], 2 ) .)
				  | number 					(. num = int( self.token.val ) .)
				  | "(" Conditional<out num, foo> ")" 
				) 
				.

//  FunctionCall         = "(" [ ActualParameters ] ")" .

//  ActualParameters     = Expression { "," Expression } .

//  AssignmentOperator   = "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "&="
//                         | "^=" | "|=" | "<<=" | ">>=" .

  UnaryOperator			= 
				("+" | "-" | "|" | "^" | "!" | "&" | "~") 
				.


  Cond<out r>			= Src<out r> . 
			/*( RegName | "[" RegName "]" ) . */


  Dst<out r>			= Src<out r> .


  Src<out r>			= 						(. r = {'r': 0, 'rop': 3, 'isptr': 0} .)
				( 
				    ("Z" | "z")	
				  | RegOp<out r>				(. r['isptr'] = 0 .)
				  | "[" RegOp<out r> "]"			(. r['isptr'] = 1 .)
				) 
				.


  RegOp<out r>			= 
				RegName<out r> 					(. r['rop'] = 0 .)
				[ 
				    "++"					(. r['rop'] = 1 .)
				  | "--"					(. r['rop'] = 2 .)
				] 
				.

  RegName< out r >		= 						(. r = {'r': 0, 'rop': 0, 'isptr': 0} .)
				(
				    "r0"					(. r['r'] = 0 .)
				  | "r1"					(. r['r'] = 1 .)
				  | "r2"					(. r['r'] = 2 .)
				  | "r3"					(. r['r'] = 3 .)
				  | "r4"					(. r['r'] = 4 .)
				  | "r5"					(. r['r'] = 5 .)
				  | "r6"					(. r['r'] = 6 .)
				  | "r7"					(. r['r'] = 7 .)
				  | "r8"					(. r['r'] = 8 .)
				  | "r9"					(. r['r'] = 9 .)
				  | "r10"					(. r['r'] = 10 .)
				  | "r11"					(. r['r'] = 11 .)
				  | "r12"					(. r['r'] = 12 .)
				  | "r13"					(. r['r'] = 13 .)
				  | "r14"					(. r['r'] = 14 .)
				  | ("r15" | "ip")				(. r['r'] = 15 .)
				) 
				.


END Asm.
